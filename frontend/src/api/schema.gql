# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Asset_price_1dCountAggregate {
  open_time: Int!
  assetInfoId: Int!
  openPrice: Int!
  closePrice: Int!
  highPrice: Int!
  lowPrice: Int!
  volume: Int!
  _all: Int!
}

type Asset_price_1dAvgAggregate {
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type Asset_price_1dSumAggregate {
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type Asset_price_1dMinAggregate {
  open_time: DateTime
  assetInfoId: String
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type Asset_price_1dMaxAggregate {
  open_time: DateTime
  assetInfoId: String
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type Asset_price_1hCountAggregate {
  open_time: Int!
  assetInfoId: Int!
  openPrice: Int!
  closePrice: Int!
  highPrice: Int!
  lowPrice: Int!
  volume: Int!
  _all: Int!
}

type Asset_price_1hAvgAggregate {
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type Asset_price_1hSumAggregate {
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type Asset_price_1hMinAggregate {
  open_time: DateTime
  assetInfoId: String
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type Asset_price_1hMaxAggregate {
  open_time: DateTime
  assetInfoId: String
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type Asset_price_5mCountAggregate {
  open_time: Int!
  assetInfoId: Int!
  openPrice: Int!
  closePrice: Int!
  highPrice: Int!
  lowPrice: Int!
  volume: Int!
  _all: Int!
}

type Asset_price_5mAvgAggregate {
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type Asset_price_5mSumAggregate {
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type Asset_price_5mMinAggregate {
  open_time: DateTime
  assetInfoId: String
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type Asset_price_5mMaxAggregate {
  open_time: DateTime
  assetInfoId: String
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type UserCountAggregate {
  id: Int!
  email: Int!
  name: Int!
  password: Int!
  otp: Int!
  otpPurpose: Int!
  _all: Int!
}

type UserAvgAggregate {
  id: Float
}

type UserSumAggregate {
  id: Int
}

type UserMinAggregate {
  id: Int
  email: String
  name: String
  password: String
  otp: String
  otpPurpose: OtpPurpose
}

enum OtpPurpose {
  VERIFY_ACCOUNT
  RESET_PASSWORD
}

type UserMaxAggregate {
  id: Int
  email: String
  name: String
  password: String
  otp: String
  otpPurpose: OtpPurpose
}

type UserCount {
  cryptoProfiles: Int!
}

type AssetPrice {
  assetInfoId: String!
  interval: String!
  open_time: DateTime!
  close_time: DateTime!
  openPrice: Float!
  closePrice: Float!
  highPrice: Float!
  lowPrice: Float!
  volume: Float!
  assetInfo: AssetInfo!
}

type AssetInfoCount {
  assetBalances: Int!
  assetPrices: Int!
}

type AssetInfo {
  id: ID!
  name: String!
  symbol: String!
  category: String!
  desc: String!
  logo: String!
  assetBalances: [AssetBalance!]
  assetPrices: [AssetPrice!]
  _count: AssetInfoCount!
}

type AssetBalance {
  id: ID!
  cryptoProfileId: String!
  assetInfoId: String!
  balance: Float!
  locked: Float!
  assetInfo: AssetInfoOutput!
  cryptoProfile: UserCryptoProfile!
}

type HistoricalCryptoBalance {
  cryptoProfileId: String!
  time: DateTime!
  estimatedBalance: Float!
  changePercent: Float!
  changeBalance: Float!
  cryptoProfile: UserCryptoProfile!
}

type UserCryptoProfileCount {
  balances: Int!
  historicalBalances: Int!
}

type UserCryptoProfile {
  profileId: ID!
  userId: Int!
  exchanges: String!
  tradingType: TradingType!
  apiKey: String!
  secretKey: String!
  balances: [AssetBalance!]!
  historicalBalances: [HistoricalCryptoBalance!]!
  user: User!
  _count: UserCryptoProfileCount!
}

enum TradingType {
  FUTURES
  SPOT
}

type User {
  id: ID!
  email: String!
  name: String
  password: String!
  otp: String
  otpPurpose: OtpPurpose
  cryptoProfiles: UserCryptoProfile!
  _count: UserCount!
}

type LoginResDto {
  accessToken: String!
  refreshToken: String!
}

type SignupResDto {
  accessToken: String!
  refreshToken: String!
}

type UserCryptoProfileCountAggregate {
  profileId: Int!
  userId: Int!
  exchanges: Int!
  tradingType: Int!
  apiKey: Int!
  secretKey: Int!
  _all: Int!
}

type UserCryptoProfileAvgAggregate {
  userId: Float
}

type UserCryptoProfileSumAggregate {
  userId: Int
}

type UserCryptoProfileMinAggregate {
  profileId: String
  userId: Int
  exchanges: String
  tradingType: TradingType
  apiKey: String
  secretKey: String
}

type UserCryptoProfileMaxAggregate {
  profileId: String
  userId: Int
  exchanges: String
  tradingType: TradingType
  apiKey: String
  secretKey: String
}

type CreateCryptoRes {
  userId: Float!
}

type HistoricalCryptoBalanceCountAggregate {
  cryptoProfileId: Int!
  time: Int!
  estimatedBalance: Int!
  changePercent: Int!
  changeBalance: Int!
  _all: Int!
}

type HistoricalCryptoBalanceAvgAggregate {
  estimatedBalance: Float
  changePercent: Float
  changeBalance: Float
}

type HistoricalCryptoBalanceSumAggregate {
  estimatedBalance: Float
  changePercent: Float
  changeBalance: Float
}

type HistoricalCryptoBalanceMinAggregate {
  cryptoProfileId: String
  time: DateTime
  estimatedBalance: Float
  changePercent: Float
  changeBalance: Float
}

type HistoricalCryptoBalanceMaxAggregate {
  cryptoProfileId: String
  time: DateTime
  estimatedBalance: Float
  changePercent: Float
  changeBalance: Float
}

type AssetBalanceCountAggregate {
  id: Int!
  cryptoProfileId: Int!
  assetInfoId: Int!
  balance: Int!
  locked: Int!
  _all: Int!
}

type AssetBalanceAvgAggregate {
  balance: Float
  locked: Float
}

type AssetBalanceSumAggregate {
  balance: Float
  locked: Float
}

type AssetBalanceMinAggregate {
  id: String
  cryptoProfileId: String
  assetInfoId: String
  balance: Float
  locked: Float
}

type AssetBalanceMaxAggregate {
  id: String
  cryptoProfileId: String
  assetInfoId: String
  balance: Float
  locked: Float
}

type AssetInfoCountAggregate {
  id: Int!
  name: Int!
  symbol: Int!
  category: Int!
  desc: Int!
  logo: Int!
  _all: Int!
}

type AssetInfoMinAggregate {
  id: String
  name: String
  symbol: String
  category: String
  desc: String
  logo: String
}

type AssetInfoMaxAggregate {
  id: String
  name: String
  symbol: String
  category: String
  desc: String
  logo: String
}

type AssetInfoOutput {
  id: ID
  name: String
  symbol: String
  category: String
  desc: String
  logo: String
  assetBalances: [AssetBalance!]
  assetPrices: [AssetPrice!]
  _count: AssetInfoCount
  lastPrice: Float!
}

type AssetPriceCountAggregate {
  assetInfoId: Int!
  interval: Int!
  open_time: Int!
  close_time: Int!
  openPrice: Int!
  closePrice: Int!
  highPrice: Int!
  lowPrice: Int!
  volume: Int!
  _all: Int!
}

type AssetPriceAvgAggregate {
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type AssetPriceSumAggregate {
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type AssetPriceMinAggregate {
  assetInfoId: String
  interval: String
  open_time: DateTime
  close_time: DateTime
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type AssetPriceMaxAggregate {
  assetInfoId: String
  interval: String
  open_time: DateTime
  close_time: DateTime
  openPrice: Float
  closePrice: Float
  highPrice: Float
  lowPrice: Float
  volume: Float
}

type Query {
  getMe: User!
  getCryptoProfiles(data: GetCryptoProfileInput!): [UserCryptoProfile!]!
  getAssetInfo(data: GetAssetInfoInput!): AssetInfo!
  getAssetPrices(data: GetAssetPriceInput!): [AssetPrice!]!
}

input GetCryptoProfileInput {
  userId: Int!
}

input GetAssetInfoInput {
  id: String!
}

input GetAssetPriceInput {
  assetInfoId: String!
  timeFrame: String!
}

type Mutation {
  createCryptoProfile(data: CreateCryptoProfileInput!): CreateCryptoRes!
  login(data: LoginReqDto!): LoginResDto!
  signup(data: UserCreateInput!): SignupResDto!
  verifyAccount(data: VerifyDto!): LoginResDto!
}

input CreateCryptoProfileInput {
  userId: Int!
  apiKey: String!
  secretKey: String!
}

input LoginReqDto {
  email: String!
  password: String!
}

input UserCreateInput {
  email: String!
  name: String
  password: String!
  otp: String
  otpPurpose: OtpPurpose
  cryptoProfiles: UserCryptoProfileCreateNestedManyWithoutUserInput
}

input UserCryptoProfileCreateNestedManyWithoutUserInput {
  create: [UserCryptoProfileCreateWithoutUserInput!]
  connectOrCreate: [UserCryptoProfileCreateOrConnectWithoutUserInput!]
  createMany: UserCryptoProfileCreateManyUserInputEnvelope
  connect: [UserCryptoProfileWhereUniqueInput!]
}

input UserCryptoProfileCreateWithoutUserInput {
  profileId: String
  exchanges: String
  tradingType: TradingType!
  apiKey: String!
  secretKey: String!
  balances: AssetBalanceCreateNestedManyWithoutCryptoProfileInput
  historicalBalances: HistoricalCryptoBalanceCreateNestedManyWithoutCryptoProfileInput
}

input AssetBalanceCreateNestedManyWithoutCryptoProfileInput {
  create: [AssetBalanceCreateWithoutCryptoProfileInput!]
  connectOrCreate: [AssetBalanceCreateOrConnectWithoutCryptoProfileInput!]
  createMany: AssetBalanceCreateManyCryptoProfileInputEnvelope
  connect: [AssetBalanceWhereUniqueInput!]
}

input AssetBalanceCreateWithoutCryptoProfileInput {
  id: String
  balance: Float!
  locked: Float!
  assetInfo: AssetInfoCreateNestedOneWithoutAssetBalancesInput!
}

input AssetInfoCreateNestedOneWithoutAssetBalancesInput {
  create: AssetInfoCreateWithoutAssetBalancesInput
  connectOrCreate: AssetInfoCreateOrConnectWithoutAssetBalancesInput
  connect: AssetInfoWhereUniqueInput
}

input AssetInfoCreateWithoutAssetBalancesInput {
  id: String
  name: String!
  symbol: String!
  category: String!
  desc: String!
  logo: String!
  assetPrices: AssetPriceCreateNestedManyWithoutAssetInfoInput
}

input AssetPriceCreateNestedManyWithoutAssetInfoInput {
  create: [AssetPriceCreateWithoutAssetInfoInput!]
  connectOrCreate: [AssetPriceCreateOrConnectWithoutAssetInfoInput!]
  createMany: AssetPriceCreateManyAssetInfoInputEnvelope
  connect: [AssetPriceWhereUniqueInput!]
}

input AssetPriceCreateWithoutAssetInfoInput {
  interval: String!
  open_time: DateTime!
  close_time: DateTime!
  openPrice: Float!
  closePrice: Float!
  highPrice: Float!
  lowPrice: Float!
  volume: Float!
}

input AssetPriceCreateOrConnectWithoutAssetInfoInput {
  where: AssetPriceWhereUniqueInput!
  create: AssetPriceCreateWithoutAssetInfoInput!
}

input AssetPriceWhereUniqueInput {
  assetInfoId_open_time: AssetPriceAssetInfoIdOpen_timeCompoundUniqueInput
  AND: [AssetPriceWhereInput!]
  OR: [AssetPriceWhereInput!]
  NOT: [AssetPriceWhereInput!]
  assetInfoId: StringFilter
  interval: StringFilter
  open_time: DateTimeFilter
  close_time: DateTimeFilter
  openPrice: FloatFilter
  closePrice: FloatFilter
  highPrice: FloatFilter
  lowPrice: FloatFilter
  volume: FloatFilter
  assetInfo: AssetInfoRelationFilter
}

input AssetPriceAssetInfoIdOpen_timeCompoundUniqueInput {
  assetInfoId: String!
  open_time: DateTime!
}

input AssetPriceWhereInput {
  AND: [AssetPriceWhereInput!]
  OR: [AssetPriceWhereInput!]
  NOT: [AssetPriceWhereInput!]
  assetInfoId: StringFilter
  interval: StringFilter
  open_time: DateTimeFilter
  close_time: DateTimeFilter
  openPrice: FloatFilter
  closePrice: FloatFilter
  highPrice: FloatFilter
  lowPrice: FloatFilter
  volume: FloatFilter
  assetInfo: AssetInfoRelationFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input DateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input FloatFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatFilter
}

input NestedFloatFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatFilter
}

input AssetInfoRelationFilter {
  is: AssetInfoWhereInput
  isNot: AssetInfoWhereInput
}

input AssetInfoWhereInput {
  AND: [AssetInfoWhereInput!]
  OR: [AssetInfoWhereInput!]
  NOT: [AssetInfoWhereInput!]
  id: StringFilter
  name: StringFilter
  symbol: StringFilter
  category: StringFilter
  desc: StringFilter
  logo: StringFilter
  assetBalances: AssetBalanceListRelationFilter
  assetPrices: AssetPriceListRelationFilter
}

input AssetBalanceListRelationFilter {
  every: AssetBalanceWhereInput
  some: AssetBalanceWhereInput
  none: AssetBalanceWhereInput
}

input AssetBalanceWhereInput {
  AND: [AssetBalanceWhereInput!]
  OR: [AssetBalanceWhereInput!]
  NOT: [AssetBalanceWhereInput!]
  id: StringFilter
  cryptoProfileId: StringFilter
  assetInfoId: StringFilter
  balance: FloatFilter
  locked: FloatFilter
  assetInfo: AssetInfoRelationFilter
  cryptoProfile: UserCryptoProfileRelationFilter
}

input UserCryptoProfileRelationFilter {
  is: UserCryptoProfileWhereInput
  isNot: UserCryptoProfileWhereInput
}

input UserCryptoProfileWhereInput {
  AND: [UserCryptoProfileWhereInput!]
  OR: [UserCryptoProfileWhereInput!]
  NOT: [UserCryptoProfileWhereInput!]
  profileId: StringFilter
  userId: IntFilter
  exchanges: StringFilter
  tradingType: EnumTradingTypeFilter
  apiKey: StringFilter
  secretKey: StringFilter
  balances: AssetBalanceListRelationFilter
  historicalBalances: HistoricalCryptoBalanceListRelationFilter
  user: UserRelationFilter
}

input IntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input NestedIntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input EnumTradingTypeFilter {
  equals: TradingType
  in: [TradingType!]
  notIn: [TradingType!]
  not: NestedEnumTradingTypeFilter
}

input NestedEnumTradingTypeFilter {
  equals: TradingType
  in: [TradingType!]
  notIn: [TradingType!]
  not: NestedEnumTradingTypeFilter
}

input HistoricalCryptoBalanceListRelationFilter {
  every: HistoricalCryptoBalanceWhereInput
  some: HistoricalCryptoBalanceWhereInput
  none: HistoricalCryptoBalanceWhereInput
}

input HistoricalCryptoBalanceWhereInput {
  AND: [HistoricalCryptoBalanceWhereInput!]
  OR: [HistoricalCryptoBalanceWhereInput!]
  NOT: [HistoricalCryptoBalanceWhereInput!]
  cryptoProfileId: StringFilter
  time: DateTimeFilter
  estimatedBalance: FloatFilter
  changePercent: FloatFilter
  changeBalance: FloatFilter
  cryptoProfile: UserCryptoProfileRelationFilter
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IntFilter
  email: StringFilter
  name: StringNullableFilter
  password: StringFilter
  otp: StringNullableFilter
  otpPurpose: EnumOtpPurposeNullableFilter
  cryptoProfiles: UserCryptoProfileListRelationFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input EnumOtpPurposeNullableFilter {
  equals: OtpPurpose
  in: [OtpPurpose!]
  notIn: [OtpPurpose!]
  not: NestedEnumOtpPurposeNullableFilter
}

input NestedEnumOtpPurposeNullableFilter {
  equals: OtpPurpose
  in: [OtpPurpose!]
  notIn: [OtpPurpose!]
  not: NestedEnumOtpPurposeNullableFilter
}

input UserCryptoProfileListRelationFilter {
  every: UserCryptoProfileWhereInput
  some: UserCryptoProfileWhereInput
  none: UserCryptoProfileWhereInput
}

input AssetPriceListRelationFilter {
  every: AssetPriceWhereInput
  some: AssetPriceWhereInput
  none: AssetPriceWhereInput
}

input AssetPriceCreateManyAssetInfoInputEnvelope {
  data: [AssetPriceCreateManyAssetInfoInput!]!
  skipDuplicates: Boolean
}

input AssetPriceCreateManyAssetInfoInput {
  interval: String!
  open_time: DateTime!
  close_time: DateTime!
  openPrice: Float!
  closePrice: Float!
  highPrice: Float!
  lowPrice: Float!
  volume: Float!
}

input AssetInfoCreateOrConnectWithoutAssetBalancesInput {
  where: AssetInfoWhereUniqueInput!
  create: AssetInfoCreateWithoutAssetBalancesInput!
}

input AssetInfoWhereUniqueInput {
  id: String
  AND: [AssetInfoWhereInput!]
  OR: [AssetInfoWhereInput!]
  NOT: [AssetInfoWhereInput!]
  name: StringFilter
  symbol: StringFilter
  category: StringFilter
  desc: StringFilter
  logo: StringFilter
  assetBalances: AssetBalanceListRelationFilter
  assetPrices: AssetPriceListRelationFilter
}

input AssetBalanceCreateOrConnectWithoutCryptoProfileInput {
  where: AssetBalanceWhereUniqueInput!
  create: AssetBalanceCreateWithoutCryptoProfileInput!
}

input AssetBalanceWhereUniqueInput {
  id: String
  AND: [AssetBalanceWhereInput!]
  OR: [AssetBalanceWhereInput!]
  NOT: [AssetBalanceWhereInput!]
  cryptoProfileId: StringFilter
  assetInfoId: StringFilter
  balance: FloatFilter
  locked: FloatFilter
  assetInfo: AssetInfoRelationFilter
  cryptoProfile: UserCryptoProfileRelationFilter
}

input AssetBalanceCreateManyCryptoProfileInputEnvelope {
  data: [AssetBalanceCreateManyCryptoProfileInput!]!
  skipDuplicates: Boolean
}

input AssetBalanceCreateManyCryptoProfileInput {
  id: String
  assetInfoId: String!
  balance: Float!
  locked: Float!
}

input HistoricalCryptoBalanceCreateNestedManyWithoutCryptoProfileInput {
  create: [HistoricalCryptoBalanceCreateWithoutCryptoProfileInput!]
  connectOrCreate: [HistoricalCryptoBalanceCreateOrConnectWithoutCryptoProfileInput!]
  createMany: HistoricalCryptoBalanceCreateManyCryptoProfileInputEnvelope
  connect: [HistoricalCryptoBalanceWhereUniqueInput!]
}

input HistoricalCryptoBalanceCreateWithoutCryptoProfileInput {
  time: DateTime!
  estimatedBalance: Float!
  changePercent: Float!
  changeBalance: Float!
}

input HistoricalCryptoBalanceCreateOrConnectWithoutCryptoProfileInput {
  where: HistoricalCryptoBalanceWhereUniqueInput!
  create: HistoricalCryptoBalanceCreateWithoutCryptoProfileInput!
}

input HistoricalCryptoBalanceWhereUniqueInput {
  cryptoProfileId_time: HistoricalCryptoBalanceCryptoProfileIdTimeCompoundUniqueInput
  AND: [HistoricalCryptoBalanceWhereInput!]
  OR: [HistoricalCryptoBalanceWhereInput!]
  NOT: [HistoricalCryptoBalanceWhereInput!]
  cryptoProfileId: StringFilter
  time: DateTimeFilter
  estimatedBalance: FloatFilter
  changePercent: FloatFilter
  changeBalance: FloatFilter
  cryptoProfile: UserCryptoProfileRelationFilter
}

input HistoricalCryptoBalanceCryptoProfileIdTimeCompoundUniqueInput {
  cryptoProfileId: String!
  time: DateTime!
}

input HistoricalCryptoBalanceCreateManyCryptoProfileInputEnvelope {
  data: [HistoricalCryptoBalanceCreateManyCryptoProfileInput!]!
  skipDuplicates: Boolean
}

input HistoricalCryptoBalanceCreateManyCryptoProfileInput {
  time: DateTime!
  estimatedBalance: Float!
  changePercent: Float!
  changeBalance: Float!
}

input UserCryptoProfileCreateOrConnectWithoutUserInput {
  where: UserCryptoProfileWhereUniqueInput!
  create: UserCryptoProfileCreateWithoutUserInput!
}

input UserCryptoProfileWhereUniqueInput {
  profileId: String
  AND: [UserCryptoProfileWhereInput!]
  OR: [UserCryptoProfileWhereInput!]
  NOT: [UserCryptoProfileWhereInput!]
  userId: IntFilter
  exchanges: StringFilter
  tradingType: EnumTradingTypeFilter
  apiKey: StringFilter
  secretKey: StringFilter
  balances: AssetBalanceListRelationFilter
  historicalBalances: HistoricalCryptoBalanceListRelationFilter
  user: UserRelationFilter
}

input UserCryptoProfileCreateManyUserInputEnvelope {
  data: [UserCryptoProfileCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input UserCryptoProfileCreateManyUserInput {
  profileId: String
  exchanges: String
  tradingType: TradingType!
  apiKey: String!
  secretKey: String!
}

input VerifyDto {
  otp: String!
  otpPurpose: OtpPurpose!
}

type Subscription {
  profileCreated(data: GetCryptoProfileInput!): UserCryptoProfile!
  newAssetPrice1m(data: GetAssetPriceInput!): AssetPrice!
  newAssetPrice5m(data: GetAssetPriceInput!): AssetPrice!
}